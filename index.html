<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Guardians Remnant – Creator Engine (Step 3: Sprite Tiles)</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #0b1320;
    overflow: hidden;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }
  #log {
    position: fixed;
    left: 10px;
    top: 10px;
    z-index: 30;
    color: #7fd4ff;
    font: 14px system-ui, -apple-system, BlinkMacSystemFont;
    background: rgba(0,0,0,0.35);
    padding: 10px;
    border-radius: 8px;
    border: 1px solid rgba(127,212,255,0.35);
    white-space: pre;
    max-width: calc(100vw - 20px);
  }
  #topui {
    position: fixed;
    right: 10px;
    top: 10px;
    z-index: 35;
    display: flex;
    gap: 8px;
  }
  button {
    background: rgba(18, 35, 63, 0.85);
    color: #7fd4ff;
    border: 1px solid rgba(127,212,255,0.35);
    padding: 8px 12px;
    border-radius: 10px;
    font: 14px system-ui;
  }
  #palette {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    height: 86px;
    z-index: 40;
    display: flex;
    gap: 10px;
    padding: 10px 12px;
    background: rgba(0,0,0,0.55);
    border-top: 1px solid rgba(127,212,255,0.20);
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  .tileBtn {
    min-width: 64px;
    height: 64px;
    border-radius: 12px;
    border: 2px solid rgba(127,212,255,0.20);
    background: rgba(10,20,35,0.35);
    display: grid;
    place-items: center;
    position: relative;
    flex: 0 0 auto;
  }
  .tileBtn.selected {
    border-color: rgba(127,212,255,0.90);
    box-shadow: 0 0 0 2px rgba(127,212,255,0.25) inset;
  }
  .tileBtn span {
    position: absolute;
    bottom: -2px;
    left: 0;
    right: 0;
    text-align: center;
    font: 10px system-ui;
    color: rgba(127,212,255,0.8);
    transform: translateY(100%);
    padding-top: 6px;
    white-space: nowrap;
  }
  canvas { display: block; }
</style>
</head>
<body>

<div id="log">Booting…</div>
<div id="topui">
  <button id="clear">Clear</button>
  <button id="export">Export</button>
</div>

<canvas id="game"></canvas>
<div id="palette"></div>

<script type="module">
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const logEl = document.getElementById("log");
const paletteEl = document.getElementById("palette");

const TILE = 32;
const STORAGE_KEY = "gr_map_v2_sprite";

// ---- DPR-safe resize ----
function resize(){
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(window.innerWidth * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  canvas.style.width = window.innerWidth + "px";
  canvas.style.height = window.innerHeight + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resize);
resize();

function log(msg){ logEl.textContent = msg; }

// ---- Sprite generation helpers (creates real PNG sprites as data URLs) ----
function makeSprite(drawFn){
  const c = document.createElement("canvas");
  c.width = TILE; c.height = TILE;
  const g = c.getContext("2d");
  drawFn(g);
  const img = new Image();
  img.src = c.toDataURL("image/png");
  return img;
}

// Pixel-art-ish tiles (original placeholders)
const TileDefs = [
  {
    id: 1, name: "Grass",
    sprite: makeSprite((g) => {
      g.fillStyle = "#1a7f3a"; g.fillRect(0,0,TILE,TILE);
      g.fillStyle = "#25a64a";
      for (let i=0;i<70;i++){
        const x = (Math.random()*TILE)|0;
        const y = (Math.random()*TILE)|0;
        g.fillRect(x,y,1,1);
      }
      g.fillStyle = "rgba(255,255,255,0.10)";
      g.fillRect(0,0,TILE,4);
    })
  },
  {
    id: 2, name: "Dirt",
    sprite: makeSprite((g) => {
      g.fillStyle = "#6b3f24"; g.fillRect(0,0,TILE,TILE);
      g.fillStyle = "#8a5832";
      for (let i=0;i<90;i++){
        const x=(Math.random()*TILE)|0, y=(Math.random()*TILE)|0;
        g.fillRect(x,y,1,1);
      }
      g.fillStyle="rgba(0,0,0,0.10)";
      g.fillRect(0,TILE-4,TILE,4);
    })
  },
  {
    id: 3, name: "Stone",
    sprite: makeSprite((g) => {
      g.fillStyle = "#59606b"; g.fillRect(0,0,TILE,TILE);
      g.fillStyle = "#747c89";
      for (let i=0;i<80;i++){
        const x=(Math.random()*TILE)|0, y=(Math.random()*TILE)|0;
        g.fillRect(x,y,1,1);
      }
      g.strokeStyle="rgba(255,255,255,0.15)";
      g.beginPath(); g.moveTo(4,10); g.lineTo(28,6); g.stroke();
      g.beginPath(); g.moveTo(6,22); g.lineTo(26,26); g.stroke();
    })
  },
  {
    id: 4, name: "Water",
    sprite: makeSprite((g) => {
      g.fillStyle = "#0b4ea2"; g.fillRect(0,0,TILE,TILE);
      g.fillStyle = "rgba(90,190,255,0.65)";
      for (let y=6; y<TILE; y+=8){
        g.beginPath();
        g.ellipse(10, y, 8, 3, 0, 0, Math.PI*2);
        g.fill();
        g.beginPath();
        g.ellipse(24, y+2, 7, 3, 0, 0, Math.PI*2);
        g.fill();
      }
      g.fillStyle = "rgba(255,255,255,0.10)";
      g.fillRect(0,0,TILE,3);
    })
  },
];

const Eraser = {
  id: 0,
  name: "Eraser",
  sprite: makeSprite((g)=>{
    g.fillStyle = "#14243f"; g.fillRect(0,0,TILE,TILE);
    g.strokeStyle = "rgba(127,212,255,0.55)";
    g.lineWidth = 2;
    g.beginPath(); g.moveTo(6,6); g.lineTo(26,26); g.stroke();
    g.beginPath(); g.moveTo(26,6); g.lineTo(6,26); g.stroke();
  })
};

const TilesById = new Map(TileDefs.map(t => [t.id, t]));
TilesById.set(Eraser.id, Eraser);

// ---- Map storage: key "x,y" => tileId ----
let map = loadMap();

function loadMap(){
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return {};
    const obj = JSON.parse(raw);
    return obj && typeof obj === "object" ? obj : {};
  } catch { return {}; }
}
function saveMap(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(map)); }
function clearMap(){ map = {}; localStorage.removeItem(STORAGE_KEY); }

// ---- Palette UI ----
let selected = TileDefs[0]; // default Grass
function makeTileButton(tile){
  const btn = document.createElement("div");
  btn.className = "tileBtn" + (tile.id === selected.id ? " selected" : "");
  const mini = document.createElement("canvas");
  mini.width = 48; mini.height = 48;
  const mctx = mini.getContext("2d");
  // draw once sprite is ready
  tile.sprite.onload = () => {
    mctx.imageSmoothingEnabled = false;
    mctx.drawImage(tile.sprite, 0, 0, mini.width, mini.height);
  };
  // if already cached
  if (tile.sprite.complete) {
    mctx.imageSmoothingEnabled = false;
    mctx.drawImage(tile.sprite, 0, 0, mini.width, mini.height);
  }
  btn.appendChild(mini);

  const label = document.createElement("span");
  label.textContent = tile.name;
  btn.appendChild(label);

  btn.addEventListener("click", () => {
    selected = tile;
    document.querySelectorAll(".tileBtn").forEach(el => el.classList.remove("selected"));
    btn.classList.add("selected");
  });

  return btn;
}

paletteEl.appendChild(makeTileButton(TileDefs[0]));
paletteEl.appendChild(makeTileButton(TileDefs[1]));
paletteEl.appendChild(makeTileButton(TileDefs[2]));
paletteEl.appendChild(makeTileButton(TileDefs[3]));
paletteEl.appendChild(makeTileButton(Eraser));

// ---- Buttons ----
document.getElementById("clear").addEventListener("click", () => clearMap());

document.getElementById("export").addEventListener("click", async () => {
  const json = JSON.stringify(map, null, 2);
  try {
    await navigator.clipboard.writeText(json);
    alert("Map JSON copied ✅");
    return;
  } catch {}
  const blob = new Blob([json], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "map.json";
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});

// ---- Painting (Pointer) ----
let pointerDown = false;
let downX = 0, downY = 0;
const TAP_SLOP = 8;

function screenToGrid(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const sx = clientX - rect.left;
  const sy = clientY - rect.top;
  return {
    gx: Math.floor(sx / TILE),
    gy: Math.floor(sy / TILE),
  };
}

function paintAt(clientX, clientY){
  const { gx, gy } = screenToGrid(clientX, clientY);
  const key = gx + "," + gy;

  if (selected.id === 0) {
    // eraser
    if (key in map) delete map[key];
  } else {
    map[key] = selected.id;
  }
  saveMap();
}

canvas.addEventListener("pointerdown", (e) => {
  pointerDown = true;
  downX = e.clientX; downY = e.clientY;
  canvas.setPointerCapture?.(e.pointerId);
});

canvas.addEventListener("pointerup", (e) => {
  if (!pointerDown) return;
  pointerDown = false;
  const dx = Math.abs(e.clientX - downX);
  const dy = Math.abs(e.clientY - downY);
  if (dx <= TAP_SLOP && dy <= TAP_SLOP) paintAt(e.clientX, e.clientY);
});

// ---- Render ----
let frame = 0;

function drawBackground(){
  ctx.fillStyle = "#0b1320";
  ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
}

function drawGrid(){
  ctx.strokeStyle = "rgba(127,212,255,0.22)";
  ctx.lineWidth = 1;
  for(let x = 0; x <= window.innerWidth; x += TILE){
    ctx.beginPath(); ctx.moveTo(x + 0.5, 0); ctx.lineTo(x + 0.5, window.innerHeight); ctx.stroke();
  }
  for(let y = 0; y <= window.innerHeight; y += TILE){
    ctx.beginPath(); ctx.moveTo(0, y + 0.5); ctx.lineTo(window.innerWidth, y + 0.5); ctx.stroke();
  }
}

function drawTiles(){
  ctx.imageSmoothingEnabled = false;
  for (const key in map){
    const id = map[key];
    const tile = TilesById.get(id);
    if (!tile) continue;
    const [gx, gy] = key.split(",").map(Number);
    ctx.drawImage(tile.sprite, gx * TILE, gy * TILE, TILE, TILE);
  }
}

function loop(){
  frame++;
  drawBackground();
  drawGrid();
  drawTiles();

  const count = Object.keys(map).length;
  log(
    "Step 3: Sprite tiles + palette ✅\n" +
    "Saved tiles: " + count + " | Loop: " + frame + "\n" +
    "Selected: " + selected.name + "\n" +
    "Tap to paint • Use Eraser to remove"
  );

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
